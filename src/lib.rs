//! Open Network Computing (ONC) Remote Procedure Call (RPC).
//!
//! This crate contains macros and helper types to implement remote procedure
//! call clients and servers, following the standard defined in [RFC 1057][1].
//!
//! The RPC servers and clients use [Tokio][2] for asynchronous communication.
//! A synchronous wrapper for RPC clients is also generated by the macros. This
//! wrapper has a simpler API for cases where asynchronous calls are not
//! necessary.
//!
//! To create an RPC client and/or server, a program interface must be defined.
//! This is done with the `onc_rpc!` macro. A program interface contains:
//!
//! - a program code number (a number which for new program definitions should
//!   be between 0x2000_0000 and 0x3fff_ffff);
//! - a version number (an unsigned integer);
//! - which protocol to use (currently only TCP is supported);
//! - a list of all procedures that can be called remotely, along with their
//!   respective parameters and return types.
//!
//! The `onc_rpc!` macro generates all the necessary types, and the user visible
//! generated types are a program interface trait, a server of program
//! implementations, an asynchronous client and a synchronous client. The server
//! can serve any implementation of the program interface trait, and the client
//! can connect to a server to send procedure call requests and return the
//! execution results.
//!
//! The RPC standard also defines a port mapper program, which is responsible
//! for returning the port a client must connect to in order to execute remote
//! procedure calls on a given program of a given version. A client wishing to
//! discover which port a version of a program is running on a server can query
//! the port mapper. The provided `port_mapper` module contains implementations
//! of synchronous and asynchronous client interfaces to communicate with a
//! port mapper of a server and also has a simple server implementation.
//!
//! [1]: https://tools.ietf.org/html/rfc1057
//! [2]: https://tokio.rs
//!
//! # Examples
//!
//! The first step is to define the program interface. As described above, the
//! `onc_rpc!` macro is used:
//!
//! ```
//! extern crate serde;
//! extern crate tokio_core;
//! extern crate tokio_proto;
//! extern crate tokio_service;
//!
//! #[macro_use] extern crate error_chain;
//! #[macro_use] extern crate futures;
//! #[macro_use] extern crate onc_rpc;
//! #[macro_use] extern crate serde_derive;
//!
//! onc_rpc! {
//!     program(program_module::MyProgram) {
//!         id = 0x2017_2017;
//!         version = 1;
//!
//!         procedures {
//!             10 => set(value: u32) -> SetResult<bool>,
//!             20 => get() -> GetResult<Option<u32>>,
//!         }
//!     }
//! }
//! #
//! #   fn main() {}
//! ```
//!
//! In the example above, a program was defined with ID `0x20172017` and version
//! `1`. The defined program has two remote procedures:
//!
//! - `set`: which receives an unsigned 32-bit integer value and returns a
//!   boolean representing if the operation succeeded or not;
//! - `get`: which receives no parameters but returns an optional unsigned
//!   32-bit integer, if it was previously set.
//!
//! ## Server
//!
//! To implement a server for the program we defined, we must implement the
//! program trait generated by the macro. The name of the trait is `MyProgram`.
//! This is because the text inside parenthesis at the start of the program
//! definition *must* contain a module name and a program name. The module name
//! is used to isolate all types generated by the macro. The program name
//! becomes the trait name.
//!
//! For this example, we are going to create a simple implementation of the
//! program behaviour:
//!
//! ```
//! #   extern crate serde;
//! #   extern crate tokio_core;
//! #   extern crate tokio_proto;
//! #   extern crate tokio_service;
//! #
//! #   #[macro_use] extern crate error_chain;
//! #   #[macro_use] extern crate futures;
//! #   #[macro_use] extern crate onc_rpc;
//! #   #[macro_use] extern crate serde_derive;
//! #
//! #   onc_rpc! {
//! #       program(program_module::MyProgram) {
//! #           id = 0x2017_2017;
//! #           version = 1;
//! #
//! #           procedures {
//! #               10 => set(value: u32) -> SetResult<bool>,
//! #               20 => get() -> GetResult<Option<u32>>,
//! #           }
//! #       }
//! #   }
//! #
//! #   use std::thread;
//! #   use std::time::Duration;
//! #
//! use std::sync::{Arc, Mutex};
//!
//! use futures::future::{FutureResult, IntoFuture};
//!
//! use program_module::Server;
//!
//! #[derive(Clone)]
//! pub struct SimpleMyProgram {
//!     // Wrapping the value in an Arc<Mutex<>> makes it possible to share the
//!     // program state between different connections
//!     value: Arc<Mutex<Option<u32>>>,
//! }
//!
//! impl SimpleMyProgram {
//!     // Implement a constructor
//!     pub fn new() -> Self {
//!         SimpleMyProgram {
//!             value: Arc::new(Mutex::new(None)),
//!         }
//!     }
//! }
//!
//! // Implement the MyProgram functionality
//! impl MyProgram for SimpleMyProgram {
//!     // The error type when processing fails. This is not returned to the
//!     // client, but instead returned to the request handling code to indicate
//!     // there was a serious error that forced the procedure to cancel.
//!     type Error = String;
//!
//!     // The future types for the execution of the procedures. They must have
//!     // the same error type as specified above.
//!     type SetResult = FutureResult<bool, String>;
//!     type GetResult = FutureResult<Option<u32>, String>;
//!
//!     // Implementation of the set method. Notice how the call uses a
//!     // non-mutable self borrow. This allows concurrent calls to be executed,
//!     // but requires the implementation to be aware of concurrency issues.
//!     // In this case, the Arc<Mutex<>> wrapper provides the necessary
//!     // concurrency isolation and interior mutability.
//!     fn set<V>(&self, value: V) -> Self::SetResult
//!     where
//!         V: Into<u32>,
//!     {
//!         if let Ok(mut locked_value) = self.value.lock() {
//!             let value_was_replaced = locked_value.is_some();
//!
//!             *locked_value = Some(value.into());
//!
//!             Ok(value_was_replaced).into_future()
//!         } else {
//!             Err("Failed to lock the value".to_string()).into_future()
//!         }
//!     }
//!
//!     // Implementation of the get method.
//!     fn get(&self) -> Self::GetResult {
//!         if let Ok(locked_value) = self.value.lock() {
//!             Ok(*locked_value).into_future()
//!         } else {
//!             Err("Failed to lock the value".to_string()).into_future()
//!         }
//!     }
//! }
//!
//! fn main() {
//! #       thread::spawn(serve);
//! #   }
//! #
//! #   fn serve() {
//!     let listen_address ="0.0.0.0:55005".parse().unwrap();
//!     let server = Server::new(listen_address);
//!     let program = SimpleMyProgram::new();
//!
//!     server.serve(program);
//! }
//! ```
//!
//! ## Synchronous Client
//!
//! To connect to a remote program, we can use either a synchronous client or an
//! asynchronous client. The simplest is the synchronous client. Every call
//! returns a `Result<T, onc_rpc::Error>`, because there can be errors while
//! requesting the remote call, but the result actually returned by the server
//! is `T`.
//!
//! ```
//! #   extern crate serde;
//! #   extern crate tokio_core;
//! #   extern crate tokio_proto;
//! #   extern crate tokio_service;
//! #
//! #   #[macro_use] extern crate error_chain;
//! #   #[macro_use] extern crate futures;
//! #   #[macro_use] extern crate onc_rpc;
//! #   #[macro_use] extern crate serde_derive;
//! #
//! #   onc_rpc! {
//! #       program(program_module::MyProgram) {
//! #           id = 0x2017_2017;
//! #           version = 1;
//! #
//! #           procedures {
//! #               10 => set(value: u32) -> SetResult<bool>,
//! #               20 => get() -> GetResult<Option<u32>>,
//! #           }
//! #       }
//! #   }
//! #
//! #   use std::thread;
//! #   use std::time::Duration;
//! #
//! #   use std::sync::{Arc, Mutex};
//! #
//! #   use futures::future::{FutureResult, IntoFuture};
//! #
//! use program_module::SyncClient;
//!
//! #   #[derive(Clone)]
//! #   pub struct SimpleMyProgram {
//! #       // Wrapping the value in an Arc<Mutex<>> makes it possible to share the
//! #       // program state between different connections
//! #       value: Arc<Mutex<Option<u32>>>,
//! #   }
//! #
//! #   impl SimpleMyProgram {
//! #       // Implement a constructor
//! #       pub fn new() -> Self {
//! #           SimpleMyProgram {
//! #               value: Arc::new(Mutex::new(None)),
//! #           }
//! #       }
//! #   }
//! #
//! #   // Implement the MyProgram functionality
//! #   impl MyProgram for SimpleMyProgram {
//! #       // The error type when processing fails. This is not returned to the
//! #       // client, but instead returned to the request handling code to indicate
//! #       // there was a serious error that forced the procedure to cancel.
//! #       type Error = String;
//! #
//! #       // The future types for the execution of the procedures. They must have
//! #       // the same error type as specified above.
//! #       type SetResult = FutureResult<bool, String>;
//! #       type GetResult = FutureResult<Option<u32>, String>;
//! #
//! #       // Implementation of the set method. Notice how the call uses a
//! #       // non-mutable self borrow. This allows concurrent calls to be executed,
//! #       // but requires the implementation to be aware of concurrency issues.
//! #       // In this case, the Arc<Mutex<>> wrapper provides the necessary
//! #       // concurrency isolation and interior mutability.
//! #       fn set<V>(&self, value: V) -> Self::SetResult
//! #       where
//! #           V: Into<u32>,
//! #       {
//! #           if let Ok(mut locked_value) = self.value.lock() {
//! #               let value_was_replaced = locked_value.is_some();
//! #
//! #               *locked_value = Some(value.into());
//! #
//! #               Ok(value_was_replaced).into_future()
//! #           } else {
//! #               Err("Failed to lock the value".to_string()).into_future()
//! #           }
//! #       }
//! #
//! #       // Implementation of the get method.
//! #       fn get(&self) -> Self::GetResult {
//! #           if let Ok(locked_value) = self.value.lock() {
//! #               Ok(*locked_value).into_future()
//! #           } else {
//! #               Err("Failed to lock the value".to_string()).into_future()
//! #           }
//! #       }
//! #   }
//! #
//! fn main() {
//! #       start_server();
//! #
//!     let connect_address = "127.0.0.1:55005".parse().unwrap();
//!
//!     // Here we open a connection to the program using a specified port.
//!     // If we don't know the port we can call connect that will connect to
//!     // the remote port mapper in order to discover the port to connect to
//!     let mut client =
//!         SyncClient::connect_to_known_port(connect_address).unwrap();
//!
//!     // The value should start uninitialized
//!     assert_eq!(client.get().unwrap(), None);
//!
//!     // The first set should return false, because it initializes the value
//!     assert_eq!(client.set(10u32).unwrap(), false);
//!     assert_eq!(client.get().unwrap(), Some(10));
//!
//!     // The second set should return true, because it replaces the value
//!     assert_eq!(client.set(20u32).unwrap(), true);
//!     assert_eq!(client.get().unwrap(), Some(20));
//!
//!     // The second set should also return true, for the same reason
//!     assert_eq!(client.set(25u32).unwrap(), true);
//!     assert_eq!(client.get().unwrap(), Some(25));
//! }
//! #
//! #   fn start_server() {
//! #       thread::spawn(serve);
//! #       thread::sleep(Duration::from_millis(100));
//! #   }
//! #
//! #   fn serve() {
//! #       let listen_address ="0.0.0.0:55005".parse().unwrap();
//! #       let server = program_module::Server::new(listen_address);
//! #       let program = SimpleMyProgram::new();
//! #
//! #       server.serve(program);
//! #   }
//! ```

#![warn(missing_docs)]
#![recursion_limit="128"]

extern crate byteorder;
extern crate bytes;
#[macro_use]
extern crate error_chain;
#[macro_use]
extern crate futures;
extern crate serde;
extern crate serde_bytes;
#[macro_use]
extern crate serde_derive;
extern crate serde_xdr;
extern crate tokio_core;
extern crate tokio_io;
extern crate tokio_proto;
extern crate tokio_service;

mod errors;
#[macro_use]
mod macros;
mod message;
mod record;
mod rpc;
mod service;

pub mod port_mapper;

pub use self::errors::{Error, ErrorKind, Result, ResultExt};
pub use self::message::{CallHeader, RpcMessage};
pub use self::record::{Record, RecordProtocol};
pub use self::rpc::{RpcCall, RpcProcedure, RpcProgram};
pub use self::service::{CallFuture, Connect, DeserializeWithHint,
                        FindPortAndConnect, RpcClientService, RpcRequest,
                        RpcServer, RpcServiceConfig, RpcServerService, TryFrom};
